<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux部署Prometheus+Grafana监控</title>
    <link href="/2023/07/25/Linux%E9%83%A8%E7%BD%B2Prometheus-Grafana%E7%9B%91%E6%8E%A7/"/>
    <url>/2023/07/25/Linux%E9%83%A8%E7%BD%B2Prometheus-Grafana%E7%9B%91%E6%8E%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>本文介绍如何使用Docker安装Prometheus+Grafana实现对Os和Go应用进程的监控可视化展示。</p><span id="more"></span><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><blockquote><p>本文安装主要实用工具为docker，所以按照本文操作开启前请提前安装好docker，并配置好docker的镜像加速功能，否则可能出现拉取Grafana镜像失败问题。</p></blockquote><h2 id="准备条件"><a href="#准备条件" class="headerlink" title="准备条件"></a>准备条件</h2><ol><li><code>Node Exporter</code>Prometheus 不具备直接采集OS信息的能力，需要借助采集工具，Linux需要下载Node Exporter 并开放防火墙端口9100。</li><li><code>Prometheus</code> Prometheus 是一款基于时序数据库的开源监控告警系统。主要功能是对采集到的数据进行存储和查询。</li><li><code>Grafana</code> Grafana是一个开源的，拥有丰富dashboard和图表编辑的指标分析平台，和Kibana不同的是Grafana专注于时序类图表分析，而且支持多种数据源，如Graphite、InfluxDB、Elasticsearch、Mysql、K8s、Zabbix等。</li></ol><h2 id="安装NodeExporter"><a href="#安装NodeExporter" class="headerlink" title="安装NodeExporter"></a>安装NodeExporter</h2><h3 id="1-下载node-exporter安装包"><a href="#1-下载node-exporter安装包" class="headerlink" title="1.下载node_exporter安装包"></a>1.下载node_exporter安装包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> /tmp</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -LO https://github.com/prometheus/node_exporter/releases/download/v1.6.0/node_exporter-1.6.0.linux-amd64.tar.gz</span><br></code></pre></td></tr></table></figure><h3 id="2-解压tar压缩包"><a href="#2-解压tar压缩包" class="headerlink" title="2.解压tar压缩包"></a>2.解压tar压缩包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tar -xvf node_exporter-1.6.0.linux-amd64.tar.gz</span><br></code></pre></td></tr></table></figure><h3 id="3-解压文件切换路径-x2F-usr-x2F-local-x2F-bin"><a href="#3-解压文件切换路径-x2F-usr-x2F-local-x2F-bin" class="headerlink" title="3.解压文件切换路径 &#x2F;usr&#x2F;local&#x2F;bin"></a>3.解压文件切换路径 &#x2F;usr&#x2F;local&#x2F;bin</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">mv</span> node_exporter-1.6.0.linux-amd64/node_exporter /usr/local/bin/</span><br></code></pre></td></tr></table></figure><h2 id="创建自定义Node-Exporter服务"><a href="#创建自定义Node-Exporter服务" class="headerlink" title="创建自定义Node Exporter服务"></a>创建自定义Node Exporter服务</h2><h3 id="1-创建一个node-exporter用户，来运行Node-Exporter服务。"><a href="#1-创建一个node-exporter用户，来运行Node-Exporter服务。" class="headerlink" title="1.创建一个node_exporter用户，来运行Node Exporter服务。"></a>1.创建一个node_exporter用户，来运行Node Exporter服务。</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo useradd -rs /bin/false node_exporter</span><br></code></pre></td></tr></table></figure><h3 id="2-在-systemd-下创建Node-Exporter服务文件。"><a href="#2-在-systemd-下创建Node-Exporter服务文件。" class="headerlink" title="2.在 systemd 下创建Node Exporter服务文件。"></a>2.在 systemd 下创建Node Exporter服务文件。</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo vim /etc/systemd/system/node_exporter.service</span><br></code></pre></td></tr></table></figure><h3 id="3-在服务文件中添加以下服务文件内容并保存。"><a href="#3-在服务文件中添加以下服务文件内容并保存。" class="headerlink" title="3.在服务文件中添加以下服务文件内容并保存。"></a>3.在服务文件中添加以下服务文件内容并保存。</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[Unit]<br>Description=Node Exporter<br>After=network.target<br><br>[Service]<br>User=node_exporter<br>Group=node_exporter<br>Type=simple<br>ExecStart=/usr/local/bin/node_exporter<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><h3 id="4-重新加载系统守护进程并启动Node-Exporter服务。"><a href="#4-重新加载系统守护进程并启动Node-Exporter服务。" class="headerlink" title="4.:重新加载系统守护进程并启动Node Exporter服务。"></a>4.:重新加载系统守护进程并启动Node Exporter服务。</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl daemon-reload</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl start node_exporter</span><br></code></pre></td></tr></table></figure><h3 id="5-检查Node-Exporter状态，确保其处于正常运行状态。"><a href="#5-检查Node-Exporter状态，确保其处于正常运行状态。" class="headerlink" title="5.检查Node Exporter状态，确保其处于正常运行状态。"></a>5.检查Node Exporter状态，确保其处于正常运行状态。</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl status node_exporter</span><br></code></pre></td></tr></table></figure><h3 id="6-开启服务器开机自启动Node-Exporter服务。"><a href="#6-开启服务器开机自启动Node-Exporter服务。" class="headerlink" title="6.开启服务器开机自启动Node Exporter服务。"></a>6.开启服务器开机自启动Node Exporter服务。</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl <span class="hljs-built_in">enable</span> node_exporter</span><br></code></pre></td></tr></table></figure><h3 id="7-通过metrics查看采集数据"><a href="#7-通过metrics查看采集数据" class="headerlink" title="7.通过metrics查看采集数据"></a>7.通过metrics查看采集数据</h3><p>:link:<a href="http://127.0.0.1:9100/metrics">http://127.0.0.1:9100/metrics</a> 注意这里是你配置的主机IP，我是用本地主机。</p><h2 id="安装Prometheus"><a href="#安装Prometheus" class="headerlink" title="安装Prometheus"></a>安装Prometheus</h2><blockquote><p>这里安装Prometheus我们仍然使用docker进行安装</p></blockquote><h3 id="1-拉取镜像并运行容器"><a href="#1-拉取镜像并运行容器" class="headerlink" title="1.拉取镜像并运行容器"></a>1.拉取镜像并运行容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d --name prometheus-node1  -p 9090:9090  bitnami/prometheus:latest</span><br></code></pre></td></tr></table></figure><h3 id="2-修改Prometheus-yml配置文件"><a href="#2-修改Prometheus-yml配置文件" class="headerlink" title="2.修改Prometheus.yml配置文件"></a>2.修改Prometheus.yml配置文件</h3><blockquote><p>Prometheus.yml文件决定了每次启动监控时需要监控的内容、配置等。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 首先我们拷贝容器内部的 prometheus.yml 到物理机中方便修改</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">cp</span>  prometheus-node1:/opt/bitnami/prometheus/conf/prometheus.yml prometheus.yml</span> <br></code></pre></td></tr></table></figure><h3 id="3-修改配置文件"><a href="#3-修改配置文件" class="headerlink" title="3.修改配置文件"></a>3.修改配置文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">vim prometheus.yml</span><br></code></pre></td></tr></table></figure><p><strong>prometheus.yml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># my global config</span><br><span class="hljs-attr">global:</span><br>  <span class="hljs-attr">scrape_interval:</span>     <span class="hljs-string">15s</span> <span class="hljs-comment"># Set the scrape interval to every 15 seconds. Default is every 1 minute.</span><br>  <span class="hljs-attr">evaluation_interval:</span> <span class="hljs-string">15s</span> <span class="hljs-comment"># Evaluate rules every 15 seconds. The default is every 1 minute.</span><br>  <span class="hljs-comment"># scrape_timeout is set to the global default (10s).</span><br><br><span class="hljs-comment"># Alertmanager configuration</span><br><span class="hljs-attr">alerting:</span><br>  <span class="hljs-attr">alertmanagers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">static_configs:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span><br>      <span class="hljs-comment"># - alertmanager:9093</span><br><br><span class="hljs-comment"># Load rules once and periodically evaluate them according to the global &#x27;evaluation_interval&#x27;.</span><br><span class="hljs-attr">rule_files:</span><br>  <span class="hljs-comment"># - &quot;first_rules.yml&quot;</span><br>  <span class="hljs-comment"># - &quot;second_rules.yml&quot;</span><br><br><span class="hljs-comment"># A scrape configuration containing exactly one endpoint to scrape:</span><br><span class="hljs-comment"># Here it&#x27;s Prometheus itself.</span><br><span class="hljs-attr">scrape_configs:</span><br>  <span class="hljs-comment"># The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&#x27;prometheus-node1&#x27;</span><br><br>    <span class="hljs-comment"># metrics_path defaults to &#x27;/metrics&#x27;</span><br>    <span class="hljs-comment"># scheme defaults to &#x27;http&#x27;.</span><br><br>    <span class="hljs-attr">static_configs:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&#x27;localhost:9090&#x27;</span>]<br><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&#x27;Linux&#x27;</span><br>    <span class="hljs-attr">static_configs:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&#x27;192.168.56.168:9100&#x27;</span>]<br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">instance:</span> <span class="hljs-string">Linux</span><br><br></code></pre></td></tr></table></figure><h3 id="4-保存修改后的配置到容器内"><a href="#4-保存修改后的配置到容器内" class="headerlink" title="4.保存修改后的配置到容器内"></a>4.保存修改后的配置到容器内</h3><blockquote><p>这里注意，我们修改的物理机上面的配置信息，因此我们还需要把配置文件覆盖到容器内部才能生效。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">覆盖容器内部配置文件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">cp</span> prometheus.yml  prometheus-node1:/opt/bitnami/prometheus/conf/prometheus.yml</span> <br></code></pre></td></tr></table></figure><h3 id="5-重启容器"><a href="#5-重启容器" class="headerlink" title="5.重启容器"></a>5.重启容器</h3><blockquote><p>配置文件发生变更后，需要重新启动服务才能使配置生效</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">重新启动 prometheus</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker restart  prometheus-node1</span><br></code></pre></td></tr></table></figure><h3 id="6-使用控制台"><a href="#6-使用控制台" class="headerlink" title="6.使用控制台"></a>6.使用控制台</h3><blockquote><p>我们运行的容器暴露的端口在 localhost:9090上。</p><p>点击下面链接就可以看到Prometheus运行了。</p></blockquote><p>[Prometheus]: <a href="http://localhost:9090/">http://localhost:9090</a>“Prometheus可视化控制台”</p><p><img src="http://gin-myblog.oss-cn-shenzhen.aliyuncs.com/static/source/image-20230725100652844.png" alt="image-20230725100652844"></p><h2 id="安装Grafana"><a href="#安装Grafana" class="headerlink" title="安装Grafana"></a>安装Grafana</h2><blockquote><p>这里Grafana也采用docker进行安装</p></blockquote><h3 id="1-拉取Grafana镜像"><a href="#1-拉取Grafana镜像" class="headerlink" title="1.拉取Grafana镜像"></a>1.拉取Grafana镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker pull grafana/grafana</span><br></code></pre></td></tr></table></figure><h3 id="2-制作容器"><a href="#2-制作容器" class="headerlink" title="2. 制作容器"></a>2. 制作容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d --name grafana -p 3000:3000 grafana/grafana</span><br></code></pre></td></tr></table></figure><h3 id="3-查看是否运行"><a href="#3-查看是否运行" class="headerlink" title="3.查看是否运行"></a>3.查看是否运行</h3><blockquote><p>Grafana 登录的初始账号和密码 均为 admin</p></blockquote><p>:link:<a href="http://127.0.0.1:3000/">http://127.0.0.1:3000</a></p><h3 id="4-导入数据源"><a href="#4-导入数据源" class="headerlink" title="4.导入数据源"></a>4.导入数据源</h3><p><img src="http://gin-myblog.oss-cn-shenzhen.aliyuncs.com/static/source/image-20230725101107318.png" alt="image-20230725101107318"></p><p><img src="http://gin-myblog.oss-cn-shenzhen.aliyuncs.com/static/source/image-20230725101127031.png" alt="image-20230725101127031"></p><p><img src="http://gin-myblog.oss-cn-shenzhen.aliyuncs.com/static/source/image-20230725101208776.png" alt="image-20230725101208776"></p><p><img src="http://gin-myblog.oss-cn-shenzhen.aliyuncs.com/static/source/image-20230725101218576.png" alt="image-20230725101218576"></p><h3 id="5-使用模板数据"><a href="#5-使用模板数据" class="headerlink" title="5.使用模板数据"></a>5.使用模板数据</h3><blockquote></blockquote><p><img src="http://gin-myblog.oss-cn-shenzhen.aliyuncs.com/static/source/image-20230725101343804.png" alt="image-20230725101343804"></p><p><img src="http://gin-myblog.oss-cn-shenzhen.aliyuncs.com/static/source/image-20230725101411980.png" alt="image-20230725101411980"></p><h3 id="6-效果展示"><a href="#6-效果展示" class="headerlink" title="6.效果展示"></a>6.效果展示</h3><h4 id="1-Linux"><a href="#1-Linux" class="headerlink" title="1.Linux"></a>1.Linux</h4><p><img src="http://gin-myblog.oss-cn-shenzhen.aliyuncs.com/static/source/image-20230725101622898.png" alt="image-20230725101622898"></p><h4 id="2-Golang"><a href="#2-Golang" class="headerlink" title="2.Golang"></a>2.Golang</h4><p><img src="http://gin-myblog.oss-cn-shenzhen.aliyuncs.com/static/source/image-20230725101710224.png" alt="image-20230725101710224"></p><h3 id="模板推荐"><a href="#模板推荐" class="headerlink" title="模板推荐"></a>模板推荐</h3><blockquote><p>Os 监控模板 应用进程监控模板 ,数字对应ID号。</p></blockquote><h4 id="Linux模板"><a href="#Linux模板" class="headerlink" title="Linux模板"></a>Linux模板</h4><ol><li><code>Node Exporter</code> 8919</li></ol><h4 id="Golang-监控模板"><a href="#Golang-监控模板" class="headerlink" title="Golang 监控模板"></a>Golang 监控模板</h4><ol><li><code>Go Metrics</code> 10826</li><li><code>Go Process</code>6671</li></ol>]]></content>
    
    
    <categories>
      
      <category>Golang 生态工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Prometheus</tag>
      
      <tag>Grafana</tag>
      
      <tag>监控</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用RabitMQ解决 论坛用户评论并发抢楼问题</title>
    <link href="/2023/07/11/Golang-%E4%BD%BF%E7%94%A8RabitMQ%E8%A7%A3%E5%86%B3-%E8%AE%BA%E5%9D%9B%E7%94%A8%E6%88%B7%E8%AF%84%E8%AE%BA%E5%B9%B6%E5%8F%91%E6%8A%A2%E6%A5%BC%E9%97%AE%E9%A2%98/"/>
    <url>/2023/07/11/Golang-%E4%BD%BF%E7%94%A8RabitMQ%E8%A7%A3%E5%86%B3-%E8%AE%BA%E5%9D%9B%E7%94%A8%E6%88%B7%E8%AF%84%E8%AE%BA%E5%B9%B6%E5%8F%91%E6%8A%A2%E6%A5%BC%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h1><p>本篇文章分享如何在用户评论高并发数据写入的情况下通过使用消息队列来保证评论楼层的原子性。</p><span id="more"></span><h1 id="问题引入：为何使用消息队列？"><a href="#问题引入：为何使用消息队列？" class="headerlink" title="问题引入：为何使用消息队列？"></a>问题引入：为何使用消息队列？</h1><blockquote><p>在我遇到的场景中是一个关于论坛在短时间内用户对同一个帖子进行评论遇到的并发楼层抢占问题，如果这里不做任何限制那么在同一时刻多个用户共同对帖子留言就会导致数据表Floor存储的数据不准确，进而导致原子性失效，而解决这个办法有三种选择：1.加锁控制、2.开始事务、3.使用消息队列。</p></blockquote><h2 id="1-加锁控制"><a href="#1-加锁控制" class="headerlink" title="1.加锁控制"></a>1.加锁控制</h2><p>使用互斥锁是解决并发问题的常用手段，但是相对来说，我们想要完美的解决问题 需要对 锁的粒度、锁的时机、以及放锁的时机。把握的非常精妙，大多数情况下复杂的业务场景会导致业务代码的层级较深，而互斥锁穿插在这种复杂的层级关系中一不留神就会导致诸如：琐失效、死锁……而且业务中引入了锁之后也会对我们的QPS造成影响。</p><h2 id="2-开启事务"><a href="#2-开启事务" class="headerlink" title="2. 开启事务"></a>2. 开启事务</h2><p>使用Gorm 事务也能够保证数据的原子性，这个相对来说也是较为方便和容易的，但是在开启事务时我们应该考虑如何简化dao操作尽量缩小粒度，让事务内的过程尽量简化但又能达到效果即可。</p><h2 id="3-使用消息队列"><a href="#3-使用消息队列" class="headerlink" title="3. 使用消息队列"></a>3. 使用消息队列</h2><p>它的优点是解耦、高可用、高并发；缺点是存在消息丢失、消息重复处理等问题，且实现较为复杂，需要考虑多种因素。这里使用RabbitMQ (如何保证消息队列消息不丢失这里不做说明)</p><h1 id="业务代码分析"><a href="#业务代码分析" class="headerlink" title="业务代码分析"></a>业务代码分析</h1><h2 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> model<br><br><span class="hljs-comment">// Comment 评论表</span><br><span class="hljs-keyword">type</span> Comment <span class="hljs-keyword">struct</span> &#123;<br>ID        <span class="hljs-type">uint64</span> <span class="hljs-string">`gorm:&quot;primaryKey;comment:评论ID&quot;`</span><br>Content   <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;type:longtext;comment:评论内容&quot;`</span><br>UserID    <span class="hljs-type">uint64</span> <span class="hljs-string">`gorm:&quot;index;not null;comment:评论用户ID&quot;`</span><br>ArticleID <span class="hljs-type">uint64</span> <span class="hljs-string">`gorm:&quot;index;not null;comment:文章ID&quot;`</span><br>ParentID  <span class="hljs-type">uint64</span> <span class="hljs-string">`gorm:&quot;index;not null;comment:父级评论ID&quot;`</span><br>Floor     <span class="hljs-type">uint32</span> <span class="hljs-string">`gorm:&quot;index;not null;comment:评论楼层&quot;`</span><br>State     <span class="hljs-type">uint8</span>  <span class="hljs-string">`gorm:&quot;comment:该评论状态&quot;`</span><br><br>Ctime <span class="hljs-type">int64</span> <span class="hljs-comment">// 创建时间，毫秒作为单位</span><br>Utime <span class="hljs-type">int64</span> <span class="hljs-comment">// 更新时间，毫秒作为单位</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="业务逻辑部分"><a href="#业务逻辑部分" class="headerlink" title="业务逻辑部分"></a>业务逻辑部分</h2><p><strong>daomain&#x2F;comment.go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Comment <span class="hljs-keyword">struct</span> &#123;<br>ID        <span class="hljs-type">uint64</span> <span class="hljs-comment">// 评论ID</span><br>Content   <span class="hljs-type">string</span> <span class="hljs-comment">// 评论内容</span><br>UserID    <span class="hljs-type">uint64</span> <span class="hljs-comment">// 评论用户ID</span><br>ArticleID <span class="hljs-type">uint64</span> <span class="hljs-comment">// 文章ID</span><br>ParentID  <span class="hljs-type">uint64</span> <span class="hljs-comment">// 父级评论ID</span><br>Floor     <span class="hljs-type">uint32</span> <span class="hljs-comment">// 评论楼层</span><br>State     <span class="hljs-type">uint8</span>  <span class="hljs-comment">// 该评论状态 0:正常，1：删除</span><br><br>Ctime <span class="hljs-type">int64</span> <span class="hljs-comment">// 创建时间，毫秒作为单位</span><br>Utime <span class="hljs-type">int64</span> <span class="hljs-comment">// 更新时间，毫秒作为单位</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>dao&#x2F;comment.go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">type</span> ArticleDAO <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Insert 创建评论</span><br>Insert(ctx context.Context, comment model.Comment) (<span class="hljs-type">uint64</span>, <span class="hljs-type">error</span>)<br>    <span class="hljs-comment">// GetLatestFloorByArticleID 根据 文章ID 获取评论最新楼层</span><br>GetLatestFloorByArticleID(ctx context.Context, articleID <span class="hljs-type">uint64</span>) (<span class="hljs-type">uint32</span>, <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> commentGORM <span class="hljs-keyword">struct</span> &#123;<br>db *gorm.DB<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *commentGORM)</span></span> Insert(ctx context.Context, comment model.Comment) (<span class="hljs-type">uint64</span>, <span class="hljs-type">error</span>) &#123;<br>err := c.db.WithContext(ctx).Create(&amp;comment).Error<br><span class="hljs-keyword">return</span> comment.ID, err<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *commentGORM)</span></span> GetLatestFloorByArticleID(ctx context.Context, articleID <span class="hljs-type">uint64</span>) (<span class="hljs-type">uint32</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">var</span> comment model.Comment<br>err := c.db.WithContext(ctx).Where(<span class="hljs-string">&quot;article_id=?&quot;</span>, articleID).Last(&amp;comment).Error<br><span class="hljs-keyword">return</span> comment.Floor, err<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewCommentDao</span><span class="hljs-params">(db *gorm.DB)</span></span> CommentDao &#123;<br><span class="hljs-keyword">return</span> &amp;commentGORM&#123;db: db&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>cache&#x2F;comment.go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> CommentCache <span class="hljs-keyword">interface</span> &#123;<br>ZAdd(ctx context.Context, comment ...domain.Comment) <span class="hljs-type">error</span><br>ZGet(ctx context.Context, cid <span class="hljs-type">uint64</span>, by domain.RangeBy) ([]domain.Comment, <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> commentRedisCache <span class="hljs-keyword">struct</span> &#123;<br>client *redis.Client<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *commentRedisCache)</span></span> ZAdd(ctx context.Context, comments ...domain.Comment) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br><span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> comments &#123;<br>comment := comments[i]<br>data, err := json.Marshal(comment)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-comment">// 使用 ZSet 存储 某篇文章 的评论</span><br>_, err = c.client.WithContext(ctx).ZAdd(fmt.Sprintf(<span class="hljs-string">&quot;article_comments_%d&quot;</span>, comment.ArticleID), redis.Z&#123;<br>Score:  <span class="hljs-type">float64</span>(comment.Floor),<br>Member: data,<br>&#125;).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *commentRedisCache)</span></span> ZGet(ctx context.Context, articleID <span class="hljs-type">uint64</span>, by domain.RangeBy) ([]domain.Comment, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">var</span> comments []domain.Comment<br><span class="hljs-keyword">var</span> result []<span class="hljs-type">string</span><br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br><span class="hljs-keyword">if</span> by.Order == enum.Positive &#123;<br>result, err = c.client.WithContext(ctx).ZRange(<br>fmt.Sprintf(<span class="hljs-string">&quot;article_comments_%d&quot;</span>, articleID), by.Start, by.Stop,<br>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> comments, err<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>result, err = c.client.WithContext(ctx).ZRevRange(<br>fmt.Sprintf(<span class="hljs-string">&quot;article_comments_%d&quot;</span>, articleID), by.Start, by.Stop,<br>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> comments, err<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> result &#123;<br><span class="hljs-comment">// 获取对应数据</span><br>data := result[i]<br><span class="hljs-comment">// 构建对象</span><br>entity := domain.Comment&#123;&#125;<br>err = json.Unmarshal([]<span class="hljs-type">byte</span>(data), &amp;entity)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> comments, err<br>&#125;<br>comments = <span class="hljs-built_in">append</span>(comments, entity)<br>&#125;<br><span class="hljs-keyword">return</span> comments, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewCommentRedisCache</span><span class="hljs-params">(client *redis.Client)</span></span> CommentCache &#123;<br><span class="hljs-keyword">return</span> &amp;commentRedisCache&#123;client: client&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>repo&#x2F;comment.go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> CommentRepo <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// CreateAndCached 创建评论,并写入缓存</span><br>CreateAndCached(ctx context.Context, comment domain.Comment) <span class="hljs-type">error</span><br><span class="hljs-comment">// ConsumerMQ</span><br>ConsumerMQ(ctx context.Context) <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-keyword">type</span> commentRepo <span class="hljs-keyword">struct</span> &#123;<br>dao   dao.CommentDao<br>cache cache.CommentCache<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *commentRepo)</span></span> CreateAndCached(ctx context.Context, comment domain.Comment) <span class="hljs-type">error</span> &#123;<br>comment.Ctime = utils.GetTimeMilli()<br>entity := model.Comment&#123;<br>Content:   comment.Content,<br>UserID:    comment.UserID,<br>ArticleID: comment.ArticleID,<br>ParentID:  comment.ParentID,<br>Floor:     comment.Floor,<br>Ctime:     comment.Ctime,<br>&#125;<br><span class="hljs-comment">// 存入消息队列</span><br>data, err := json.Marshal(entity)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>err = global.RabbitMQ.PublishOnQueue(ctx, data)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *commentRepo)</span></span> ConsumerMQ(ctx context.Context) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 从消息队列获取</span><br>msgs, err := global.RabbitMQ.Ch.Consume(global.RabbitMQ.QueueName, <span class="hljs-string">&quot;评论消费&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">for</span> msg := <span class="hljs-keyword">range</span> msgs &#123;<br>endData := model.Comment&#123;&#125;<br>err = json.Unmarshal(msg.Body, &amp;endData)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>floor, err := c.GetLatestFloor(ctx, endData.ArticleID)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &amp;&amp; err != gorm.ErrRecordNotFound &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>endData.Floor = floor + <span class="hljs-number">1</span><br>_, err = c.dao.Insert(ctx, endData)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-comment">// 写入缓存</span><br>err = c.cache.Set(ctx, domain.Comment(endData))<br>err = c.cache.ZAdd(ctx, domain.Comment(endData))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>global.Log.Warn(err.Error())<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> err<br>&#125;()<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewCommentRepo</span><span class="hljs-params">(dao dao.CommentDao, cache cache.CommentCache)</span></span> CommentRepo &#123;<br><span class="hljs-keyword">return</span> &amp;commentRepo&#123;dao: dao, cache: cache&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="功能详解："><a href="#功能详解：" class="headerlink" title="功能详解："></a>功能详解：</h2><p>上述代码基本代表了有关评论业务操作的repository层操作，我们从最上层接口开始逐层拆分介绍。</p><ol><li><code>repo/comment.go </code>下的 <code>ConsumerMQ(ctx context.context)</code> 方法在我们路由注册的时候进行依赖注入，使用协程启动评论消费端，等待接收生产者的信号，当用户发表评论的时候就会走 <code>CreateAndCached(ctx,comment)</code> 接口方法将用户的评论信息写入消费队列，经过消费者消费成功后，把本篇文章的评论信息追加到 <code>ZSet</code>中进行评论缓存。</li><li><code>ConsumerMQ</code> 方法中每次从消费队列获取用户评论后对该评论的所属文章进行最新楼层查询，这样保证评论的顺序性，同时也保证了写入数据库的评论楼层数也是具备原子性的。</li><li>在ApiPost 提供的并发测试接口中 并发数 5000* 5 轮的情况下，整体API接口的平均延迟在 300MS左右，可见效果还是非常不错的。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>amqp-go</tag>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GoMock 使用体会</title>
    <link href="/2023/07/04/GoMock-%E4%BD%BF%E7%94%A8%E4%BD%93%E4%BC%9A/"/>
    <url>/2023/07/04/GoMock-%E4%BD%BF%E7%94%A8%E4%BD%93%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇文章分享，分享关于gomock的使用技巧和心得。</p><span id="more"></span><h1 id="为什么要进行单元测试？"><a href="#为什么要进行单元测试？" class="headerlink" title="为什么要进行单元测试？"></a>为什么要进行单元测试？</h1><blockquote><p>:fox_face: 我们在日常软件开发过程中总会无意间创造一些神奇的BUG，而这些BUG的产生往往在初期编写代码的时候是看不出来的！为了尽量避免这类问题，我认为编写测试单元能够减少这类问题的出现。</p><p>:fox_face: gomock 能在测试中让你避开如需要 *db 等需要初始化操作,减少大量准备工作.</p></blockquote><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>提高代码质量：单元测试可以及早发现和修复代码中的错误，从而减少整体测试的时间和成本，提高代码的质量和稳定性。</li><li>减少集成错误：通过单元测试，可以将各个模块分开测试，减少模块之间的依赖性，避免在集成时出现错误。</li><li>提高代码可维护性：单元测试可以帮助开发人员快速定位和修复代码中的问题，同时也可以提供代码的文档和示例。</li><li>增加代码信心：通过编写单元测试，可以增加开发人员对代码的信心，因为他们知道他们的代码在各种情况下都能正常工作。</li><li>减少回归错误：单元测试可以在代码更改后自动运行，确保新添加的功能不会影响现有功能，从而减少回归错误。</li><li>提高可测试性：单元测试可以帮助开发人员编写更易于测试的代码，提高代码的可测试性。</li><li>增加代码覆盖率：通过单元测试，可以覆盖代码的各种情况，包括边界条件和异常处理，从而提高代码的覆盖率。</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>需要额外的工作量：编写单元测试需要额外的工作量，这会增加开发成本和时间。</li><li>测试环境与实际环境存在差异：单元测试通常在测试环境中进行，与实际环境可能存在差异，这可能导致测试结果不准确或不可靠。</li><li>覆盖范围有限：单元测试只能测试代码的表面问题，无法覆盖所有可能的情况，因此可能存在一些潜在的问题。</li><li>测试的稳定性和可靠性要求高：单元测试需要保证测试的稳定性和可靠性，否则测试结果可能会误导开发人员，导致错误的决策。</li><li>需要具备一定的测试技巧：编写单元测试往往需要有效的用例覆盖如：边界覆盖、异常覆盖等。</li></ol><h2 id="如何抉择"><a href="#如何抉择" class="headerlink" title="如何抉择"></a>如何抉择</h2><blockquote><p>其实对比上面的优缺点之后，最大的问题应该在需要额外的工作量上面，因为在严格意义的软件工程生命周期中，编码和单元测试 (20%-25% )综合测试占比更是达到(30%-40%)左右，但是我们所处的工作环境大部分都是敏捷开发，小公司往往更是测试部门都没有，所给的时间也是非常紧迫，这其实对整个软件的生态都不友好，因为后续的BUG维护会占用更长时间。</p><p>总的来说：</p><p>​如果部门预留时间充分并且有绩效反馈的编写单元测试再好不过。</p><p>​如果部门着急赶项目加班连轴转的这种还是老老实实写功能吧，不然功能延期会对后面的计划造成更大的影响。</p></blockquote><h1 id="如何使用Gomock"><a href="#如何使用Gomock" class="headerlink" title="如何使用Gomock"></a>如何使用Gomock</h1><blockquote><p>gomock 主要由两部分组成,一个是测试库,一个是mockgen.我们需要先对待测代码使用mockgen生成待测文件,再调用gomock对待测文件进行测试.</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 测试库</span><br><span class="hljs-keyword">go</span> get github.com/golang/mock/gomock<br><span class="hljs-comment">// mock代码生成器</span><br><span class="hljs-keyword">go</span> get github.com/golang/mock/mockgen<br></code></pre></td></tr></table></figure><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">目录结构</span><br>--- repository<br>--- dao<br>user.go// 用户操作Mysql<br>user.go// 例:Repository暴露接口(待测文件)<br>--- service<br>user.go// 例:用户Service层操作<br></code></pre></td></tr></table></figure><hr><p><strong>repository&#x2F;dao&#x2F;user.go</strong></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> UserDao <span class="hljs-keyword">interface</span>&#123;<br>    <span class="hljs-comment">// 例如我们定义一个 Insert 新增操作</span><br>   Insert(ctx context.Context, user model.User) (<span class="hljs-type">uint64</span>, <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewUserDao</span><span class="hljs-params">(db *gorm.DB)</span></span> UserDao &#123;<br><span class="hljs-keyword">return</span> &amp;userGORM&#123;db: db&#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> userGORM <span class="hljs-keyword">struct</span> &#123;<br>db *gorm.DB<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *userGORM)</span></span> Insert(ctx context.Context, user model.User) (<span class="hljs-type">uint64</span>, <span class="hljs-type">error</span>) &#123;<br>err := u.db.WithContext(ctx).Create(&amp;user).Error<br><span class="hljs-keyword">return</span> user.ID, err<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>repository&#x2F;user.go</strong></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 待测文件</span><br><span class="hljs-keyword">type</span> UserRepo <span class="hljs-keyword">interface</span> &#123;<br>    <span class="hljs-comment">// Create 注册</span><br>Create(ctx context.Context, user domain.User) (<span class="hljs-type">uint64</span>, <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> userRepo <span class="hljs-keyword">struct</span> &#123;<br>dao   dao.UserDao<br>cache cache.UserCache<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewUserRepo</span><span class="hljs-params">(dao dao.UserDao, cache cache.UserCache)</span></span> UserRepo &#123;<br><span class="hljs-keyword">return</span> &amp;userRepo&#123;dao: dao, cache: cache&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *userRepo)</span></span> Create(ctx context.Context, user domain.User) (<span class="hljs-type">uint64</span>, <span class="hljs-type">error</span>) &#123;<br>now := utils.GetTimeMilli()<br><span class="hljs-comment">// 创建用户</span><br><span class="hljs-keyword">if</span> user.ID != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, errors.New(<span class="hljs-string">&quot;用户已存在无法创建&quot;</span>)<br>&#125;<br>entity := model.User&#123;<br>ID:       user.ID,<br>UserName: user.UserName,<br>Password: user.Password,<br>NickName: user.NickName,<br>Email:    user.Email,<br>Phone:    user.Phone,<br>Avatar:   user.Avatar,<br>Ctime:    now,<br>Utime:    now,<br>&#125;<br><span class="hljs-keyword">return</span> u.dao.Insert(ctx, entity)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>service&#x2F;user.go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> UserService <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Register 注册</span><br>Register(ctx context.Context, user domain.User) (domain.User, <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> userService <span class="hljs-keyword">struct</span> &#123;<br>repo repository.UserRepo<br>&#125;<br><br><span class="hljs-comment">// NewUserService 注意这里的 入参是repo 实际测试过程中我们需要大量的初始化工作来拿到 repo ,但是我们用 gockgen 生成待测文件，因此可以通过生成的文件接口拿到该入参。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewUserService</span><span class="hljs-params">(repo repository.UserRepo)</span></span> UserService &#123;<br><span class="hljs-keyword">return</span> &amp;userService&#123;repo: repo&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *userService)</span></span> Register(ctx context.Context, user domain.User) (domain.User, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// 账户已存在校验</span><br><br><span class="hljs-comment">// 昵称重复校验</span><br><br><span class="hljs-comment">// 对用户密码加盐Hash</span><br>hashPwd := utils.MD5V(user.Password, <span class="hljs-string">&quot;salt&quot;</span>, <span class="hljs-number">10</span>)<br>user.Password = hashPwd<br><span class="hljs-comment">// 创建用户</span><br>uid, err := u.repo.Create(ctx, user)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> domain.User&#123;&#125;, err<br>&#125;<br>user.ID = uid<br><span class="hljs-keyword">return</span> user, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li>首先使用<code>mockgen</code>生成待测文件</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 1.我们先切换到 /repository/</span><br><span class="hljs-comment">// source 指定源文件  destination 指定生成文件 package 指定生成文件包名称</span><br>mockgen -source=user.<span class="hljs-keyword">go</span> -destination=mock_user.repo.<span class="hljs-keyword">go</span> -<span class="hljs-keyword">package</span>=repository<br></code></pre></td></tr></table></figure><ol start="2"><li>创建测试文件<code>user_test.go</code></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 编写测试用例</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestUserService</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    <span class="hljs-comment">// 这里的hashPWd 是在Service 层做的。</span><br>hashPwd := utils.MD5V(<span class="hljs-string">&quot;yyz&quot;</span>, <span class="hljs-string">&quot;salt&quot;</span>, <span class="hljs-number">10</span>)<br>testCases := []<span class="hljs-keyword">struct</span> &#123;<br>name      <span class="hljs-type">string</span><br>mock      <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctrl *gomock.Controller)</span></span> repository.UserRepo<br>inputUser domain.User<br><br>wantUser domain.User<br>wantErr  <span class="hljs-type">error</span><br>&#125;&#123;<br>&#123;<br>name:      <span class="hljs-string">&quot;注册成功案例&quot;</span>,<br>inputUser: domain.User&#123;UserName: <span class="hljs-string">&quot;xxn&quot;</span>, Password: <span class="hljs-string">&quot;yyz&quot;</span>, NickName: <span class="hljs-string">&quot;小仙女郁郁症&quot;</span>&#125;,<br>mock: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctrl *gomock.Controller)</span></span> repository.UserRepo &#123;<br>                <span class="hljs-comment">// 这里使用生成的测试文件接口直接获得 repo 返回值，可作为Newservice的入参使用。</span><br>repo := repository.NewMockUserRepo(ctrl)<br>repo.EXPECT().Create(gomock.Any(), domain.User&#123;UserName: <span class="hljs-string">&quot;xxn&quot;</span>, Password: hashPwd, NickName: <span class="hljs-string">&quot;小仙女郁郁症&quot;</span>&#125;).Return(<span class="hljs-type">uint64</span>(<span class="hljs-number">1</span>), <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">return</span> repo<br>&#125;,<br><br>wantUser: domain.User&#123;ID: <span class="hljs-number">1</span>, UserName: <span class="hljs-string">&quot;xxn&quot;</span>, Password: hashPwd, NickName: <span class="hljs-string">&quot;小仙女郁郁症&quot;</span>&#125;,<br>&#125;,<br>&#125;<br><br><span class="hljs-keyword">for</span> _, tc := <span class="hljs-keyword">range</span> testCases &#123;<br>t.Run(tc.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>ctrl := gomock.NewController(t)<br><span class="hljs-keyword">defer</span> ctrl.Finish()<br><span class="hljs-comment">// 通过Mock 获得Repo构造对象</span><br>repo := tc.mock(ctrl)<br>svc := NewUserService(repo)<br><span class="hljs-comment">// 下边进行 Service层接口调试 </span><br>user, err := svc.Register(context.Background(), tc.inputUser)<br><span class="hljs-comment">// 错误一致</span><br>assert.Equal(t, tc.wantErr, err)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 数据一致</span><br>assert.Equal(t, tc.wantUser, user)<br>&#125;)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>其实在使用 gomock 的时候我们需要清晰 那一层是需要待测的? 为什么这一层需要 gomock 的引入(因为不需要gomock我们也能测试),我们在上述的例子中对repository层user.go进行 mockgen生成待测文件就是为了绕开 dao操作中需要传入的GormDB,不然仅仅因为测试就需要大量的初始化工作这是不合理的.而这也是使用gomock的便利之处.</p><p>当然gomock还有更多的功能等待大家挖掘,以上是我的使用心得体会.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>GoMock</tag>
      
      <tag>单元测试</tag>
      
      <tag>打桩测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang - 双Token认证</title>
    <link href="/2023/05/13/Golang-%E5%8F%8CToken%E8%AE%A4%E8%AF%81/"/>
    <url>/2023/05/13/Golang-%E5%8F%8CToken%E8%AE%A4%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学会如何在 Golang 开发中使用双Token进行验证。</p><span id="more"></span><h1 id="什么是-JWT"><a href="#什么是-JWT" class="headerlink" title="什么是 JWT ?"></a>什么是 JWT ?</h1><blockquote><p><code>jwt</code> ：是 json web token 的缩写，jwt 是服务端通过特定算法生成的的一个凭证信息，主要包含 <code>Header</code>（头部）、<code>Payload</code>（载荷）、<code>Signature</code>（签名）。</p><p>因为http 是无状态的，所以客户端触发的http请求我们不知道用户的状态信息，比如这个用户已经登陆过了。所以衍生出</p></blockquote><h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><blockquote><p>令牌头部，记录了整个令牌的类型和签名算法，它是一个描述 jwt元数据的 json 对象</p></blockquote><h2 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h2><blockquote><p>JWT 第二部分是 Payload，也是一个 Json 对象，除了包含需要传递的数据，还有七个默认的字段供选择。</p><p>一般来说 至少要使用 iss 和  exp 。</p></blockquote><ul><li>iss (issuer)：签发人&#x2F;发行人</li><li>sub (subject)：主题</li><li>aud (audience)：用户</li><li>exp (expiration time)：过期时间</li><li>nbf (Not Before)：生效时间，在此之前是无效的</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：用于标识该 JWT</li></ul><h2 id="SIgnature"><a href="#SIgnature" class="headerlink" title="SIgnature"></a>SIgnature</h2><blockquote><p>JWT 第三部分是签名，主要的生成步骤有以下几点。</p></blockquote><ol><li>首先需要指定一个 secret，该 secret 仅仅保存在服务器中，保证不能让其他用户知道。这个部分需要 base64URL 加密后的 header 和 base64URL 加密后的 payload 使用 </li><li>然后通过header 中声明的加密算法 进行加盐secret组合加密，然后就得出一个签名哈希，也就是Signature，且无法反向解密。</li></ol><h2 id="校验jwt"><a href="#校验jwt" class="headerlink" title="校验jwt"></a>校验jwt</h2><blockquote><p>当服务端生成jwt传递给前端后，前端保存 jwt 信息到浏览器本地，后续请求附加到请求头的 Authorization 中，服务端通过 jwt 的 <code>Header</code> 和 <code>Payload</code> 用同一套哈希算法和同一个<code>secret</code> 计算签名值，让后把计算结果和前端传递的 jwt 第三段进行比较如果相同那么就通过验证，</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="jwt-出现场景"><a href="#jwt-出现场景" class="headerlink" title="jwt 出现场景"></a>jwt 出现场景</h3><blockquote><p>jwt 的出现是因为 http 是无状态的，并且因为使用算法进行计算校验相比服务端存储Session 节省更多资源 jwt 能够适用于更多的场景。</p></blockquote><h3 id="jwt-优缺点"><a href="#jwt-优缺点" class="headerlink" title="jwt 优缺点"></a>jwt 优缺点</h3><p><strong>优点</strong></p><ul><li>持久性：服务端不用存储生成的 jwt 信息，服务器即便重启后也能对历史的 jwt 进行校验。</li><li>节省资源：相对于通过 Session 存储用户的会话信息，服务端可以节省更多资源。</li></ul><p><strong>缺点</strong></p><ul><li>安全性：因为可以存储在客户端，那么数据就可以被篡改，并且 <code>Payload</code> 部分没有加密，只是使用了Base64进行编码，所以 jwt 不能存储敏感信息。</li><li>无法中途废弃：jwt 一旦进行签发，那么只能等到该凭据自动过期，无法强制过期，所以使用时应该尽量用合适的过期时间去签发。（双Token解决）</li><li>续签问题：jwt 什么时候续签？如果续签频繁就违背了 jwt 的设计初衷，如果不续签，又影响用户体验。（双Token 解决）</li></ul><h1 id="Golang：双Token续签"><a href="#Golang：双Token续签" class="headerlink" title="Golang：双Token续签"></a>Golang：双Token续签</h1><h2 id="实现思想"><a href="#实现思想" class="headerlink" title="实现思想"></a>实现思想</h2><blockquote><p>根据上面的jwt的缺点，我们可以分析道，jwt 续签才是问题所在，那么只要优雅的解决续签问题，其他的就好说了。</p></blockquote><h3 id="1-短Token"><a href="#1-短Token" class="headerlink" title="1.短Token"></a>1.短Token</h3><blockquote><p>我们简称 Authorization 为Atoken，他是一个包含用户信息的主体Token用来，是用户访问权限校验的真实Toekn。所以短Token的生命周期很短，但是维护要很频繁，我们这里设置过期时间为2小时。 </p></blockquote><h3 id="2-长Token"><a href="#2-长Token" class="headerlink" title="2. 长Token"></a>2. 长Token</h3><blockquote><p>我们简称 Reflash 为 Rtoken，他是一个用来帮助刷新Atoken的凭证，所以它不需要记录用户的信息，因此它需要一个较长的生命周期来保证维护短Token的更新。我们这里设置过期时间为 7 天</p></blockquote><h3 id="3-代码总览"><a href="#3-代码总览" class="headerlink" title="3.代码总览"></a>3.代码总览</h3><blockquote><p>核心思想就是：Atoken 肯定会先过期，过期后如果在Rtoken的时间范围内，那么重新生成Atoken。以此来进行维护更新。</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">package</span> utils<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;errors&quot;</span><br><span class="hljs-string">&quot;github.com/golang-jwt/jwt/v5&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> (<br>ATokenExpiredDuration = <span class="hljs-number">2</span> * time.Hour<br>RTokenExpiredDuration = <span class="hljs-number">30</span> * <span class="hljs-number">24</span> * time.Hour<br>TokenIssuer           = <span class="hljs-string">&quot;admin&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> (<br>mySecret          = []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;my Secret Decode&quot;</span>)<br>ErrorInvalidToken = errors.New(<span class="hljs-string">&quot;verify Token Failed&quot;</span>)<br>)<br><br><span class="hljs-comment">// PayLoad 载荷，注意不要存放用户敏感数据。</span><br><span class="hljs-keyword">type</span> PayLoad <span class="hljs-keyword">struct</span> &#123;<br>UserID   <span class="hljs-type">int64</span>  <span class="hljs-string">`json:&quot;user_id&quot;`</span><br>Username <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;username&quot;`</span><br>jwt.RegisteredClaims<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getJWTTime</span><span class="hljs-params">(t time.Duration)</span></span> *jwt.NumericDate &#123;<br><span class="hljs-keyword">return</span> jwt.NewNumericDate(time.Now().Add(t))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">keyFunc</span><span class="hljs-params">(token *jwt.Token)</span></span> (any, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> mySecret, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// GenToken 颁发token access token 和 refresh token</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GenToken</span><span class="hljs-params">(userID <span class="hljs-type">int64</span>, userName <span class="hljs-type">string</span>)</span></span> (atoken, rtoken <span class="hljs-type">string</span>, err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// 构建 凭证 基础信息</span><br>rc := jwt.RegisteredClaims&#123;<br>Issuer:    TokenIssuer,                       <span class="hljs-comment">// 颁发人</span><br>ExpiresAt: getJWTTime(ATokenExpiredDuration), <span class="hljs-comment">// 到期时间</span><br>&#125;<br><span class="hljs-comment">// 绑定载荷信息</span><br>at := PayLoad&#123;userID, userName, rc&#125;<br><span class="hljs-comment">// 使用SHA256对载荷非对称加密，进行签名和加盐</span><br>atoken, err = jwt.NewWithClaims(jwt.SigningMethodHS256, at).SignedString(mySecret)<br><br><span class="hljs-comment">// refresh token 长token用来刷新，所以不需要载荷。</span><br>rt := rc<br>rt.ExpiresAt = getJWTTime(RTokenExpiredDuration)<br>rtoken, err = jwt.NewWithClaims(jwt.SigningMethodHS256, rt).SignedString(mySecret)<br><br><span class="hljs-keyword">return</span> atoken, rtoken, err<br>&#125;<br><br><span class="hljs-comment">// VerifyToken 验证Token</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">VerifyToken</span><span class="hljs-params">(tokenId <span class="hljs-type">string</span>)</span></span> (pl *PayLoad, err <span class="hljs-type">error</span>) &#123;<br>token, err := jwt.ParseWithClaims(tokenId, pl, keyFunc)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> pl, err<br>&#125;<br><span class="hljs-comment">// 解析成功后为True</span><br><span class="hljs-keyword">if</span> !token.Valid &#123;<br>err = ErrorInvalidToken<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> pl, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// RefreshToken 通过refresh token 刷新 短token(atoken)</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RefreshToken</span><span class="hljs-params">(atoken, rtoken <span class="hljs-type">string</span>)</span></span> (newAtoken, newRtoken <span class="hljs-type">string</span>, err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// rtoken 无效退出</span><br><span class="hljs-keyword">if</span> _, err = jwt.Parse(rtoken, keyFunc); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 从旧的access token 中解析出 payload 数据信息</span><br><span class="hljs-keyword">var</span> claim PayLoad<br><span class="hljs-comment">// 校验不通过，并且该错误是因为Token过期引起的，那么进行续签。</span><br>_, err = jwt.ParseWithClaims(atoken, &amp;claim, keyFunc)<br><span class="hljs-keyword">if</span> err == jwt.ErrTokenExpired &#123;<br><span class="hljs-keyword">return</span> GenToken(claim.UserID, claim.Username)<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Token</tag>
      
      <tag>jwt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 发送邮件 gomail使用</title>
    <link href="/2023/02/19/Golang-%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6-gomail%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/02/19/Golang-%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6-gomail%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><blockquote><p>这里我使用的是 “gopkg.in&#x2F;gomail.v2”</p></blockquote><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">go</span> <span class="hljs-built_in">get</span> gopkg.<span class="hljs-keyword">in</span>/gomail.v2<br></code></pre></td></tr></table></figure><blockquote><p>开启 POP3&#x2F;IMAP&#x2F;SMTP&#x2F;Exchange&#x2F;CardDAV 服务 授权码</p><p>🦊：<a href="https://wx.mail.qq.com/account">https://wx.mail.qq.com/account</a></p></blockquote><h2 id="方法封装"><a href="#方法封装" class="headerlink" title="方法封装"></a>方法封装</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// SendMail 发送邮件</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SendMail</span><span class="hljs-params">(mailTo []<span class="hljs-type">string</span>, subject <span class="hljs-type">string</span>, body <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 设置邮箱主体</span><br>mailConn := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<br><span class="hljs-string">&quot;user&quot;</span>: <span class="hljs-string">&quot;xxxxxxxx@qq.com&quot;</span>, <span class="hljs-comment">//发送人邮箱（邮箱以自己的为准）</span><br><span class="hljs-string">&quot;pass&quot;</span>: <span class="hljs-string">&quot;使用上面的授权码&quot;</span>, <span class="hljs-comment">//发送人邮箱的密码，现在可能会需要邮箱 开启授权密码后在pass填写授权码</span><br><span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;smtp.qq.com&quot;</span>,      <span class="hljs-comment">//邮箱服务器（此时用的是qq邮箱）</span><br>&#125;<br><br>m := gomail.NewMessage(<br><span class="hljs-comment">//发送文本时设置编码，防止乱码。 如果txt文本设置了之后还是乱码，那可以将原txt文本在保存时</span><br><span class="hljs-comment">//就选择utf-8格式保存</span><br>gomail.SetEncoding(gomail.Base64),<br>)<br>m.SetHeader(<span class="hljs-string">&quot;From&quot;</span>, m.FormatAddress(mailConn[<span class="hljs-string">&quot;user&quot;</span>], <span class="hljs-string">&quot;LLL&quot;</span>)) <span class="hljs-comment">// 添加别名</span><br>m.SetHeader(<span class="hljs-string">&quot;To&quot;</span>, mailTo...)                                  <span class="hljs-comment">// 发送给用户(可以多个)</span><br>m.SetHeader(<span class="hljs-string">&quot;Subject&quot;</span>, subject)                               <span class="hljs-comment">// 设置邮件主题</span><br>m.SetBody(<span class="hljs-string">&quot;text/html&quot;</span>, body)                                  <span class="hljs-comment">// 设置邮件正文</span><br><br><span class="hljs-comment">//一个文件（加入发送一个 txt 文件）：/tmp/foo.txt，我需要将这个文件以邮件附件的方式进行发送，同时指定附件名为：附件.txt</span><br><span class="hljs-comment">//同时解决了文件名乱码问题</span><br>name := <span class="hljs-string">&quot;附件.txt&quot;</span><br>m.Attach(<span class="hljs-string">&quot;./gomail.txt&quot;</span>,<br>gomail.Rename(name), <span class="hljs-comment">//重命名</span><br>gomail.SetHeader(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-type">string</span>&#123;<br><span class="hljs-string">&quot;Content-Disposition&quot;</span>: []<span class="hljs-type">string</span>&#123;<br>fmt.Sprintf(<span class="hljs-string">`attachment; filename=&quot;%s&quot;`</span>, mime.QEncoding.Encode(<span class="hljs-string">&quot;UTF-8&quot;</span>, name)),<br>&#125;,<br>&#125;),<br>)<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   创建SMTP客户端，连接到远程的邮件服务器，需要指定服务器地址、端口号、用户名、密码，如果端口号为465的话，</span><br><span class="hljs-comment">   自动开启SSL，这个时候需要指定TLSConfig</span><br><span class="hljs-comment">*/</span><br>d := gomail.NewDialer(mailConn[<span class="hljs-string">&quot;host&quot;</span>], <span class="hljs-number">465</span>, mailConn[<span class="hljs-string">&quot;user&quot;</span>], mailConn[<span class="hljs-string">&quot;pass&quot;</span>]) <span class="hljs-comment">// 设置邮件正文</span><br><span class="hljs-comment">//d.TLSConfig = &amp;tls.Config&#123;InsecureSkipVerify: true&#125;</span><br>err := d.DialAndSend(m)<br><span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h2><blockquote><p>直接调用上面的方法封装函数即可</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 邮件接收方</span><br>mailTo := []<span class="hljs-type">string</span>&#123;<br><span class="hljs-comment">//可以是多个接收人</span><br><span class="hljs-string">&quot;toObject@qq.com&quot;</span>,<br>&#125;<br><br>subject := <span class="hljs-string">&quot;Hello World!&quot;</span>    <span class="hljs-comment">// 邮件主题</span><br>body := static.ParseString() <span class="hljs-comment">// 邮件正文</span><br><br>err := SendMail(mailTo, subject, body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Send fail! - &quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;Send successfully!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="小技巧-发送HTML格式的邮件内容"><a href="#小技巧-发送HTML格式的邮件内容" class="headerlink" title="小技巧-发送HTML格式的邮件内容"></a>小技巧-发送HTML格式的邮件内容</h2><blockquote><p>🦊：很多需要验证码操作的流程，我们接受邮件经常可以看到一个 小巧精致的卡片模板。这个就是封装HTML后的格式。<img src="https://lwh-zfile.oss-cn-shanghai.aliyuncs.com/Blog/image-20230219164859201.png?Expires=1676797189&OSSAccessKeyId=TMP.3KecoKYsTmoCwo9ChYAQRibrWWFYZZ1CHpXJGuAjrxSvckEyK1LUfNa6amDNAnMH6cCko4GbQ1iqAoZTzgyXbQXg2SA4eo&Signature=L17ASqyMRPBwHjCfOsOYf+Mqt9Y="></p></blockquote><p>1.创建样式模板</p><blockquote><p>例如 static&#x2F;cardEmail.html</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// ParseString 读取对应文件输出string</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ParseString</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-type">byte</span>, err := ioutil.ReadFile(<span class="hljs-string">&quot;./static/cardEmail.html&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;ReadFile error:&quot;</span>, err)<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(<span class="hljs-type">byte</span>)<br>&#125;<br><br><span class="hljs-comment">// 发送邮件</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span>&#123;<br>    styleInfo := ParseString()<br>    err := SendMail(mailTo, subject, styleInfo)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;Send Email Error&quot;</span>+err.Error())<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Golang 邮件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go-swagger安装与使用</title>
    <link href="/2023/02/17/go-swagger%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/02/17/go-swagger%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang-环境下使用-swagger"><a href="#Golang-环境下使用-swagger" class="headerlink" title="Golang 环境下使用 swagger"></a>Golang 环境下使用 swagger</h1><h2 id="1-安装swagger工具"><a href="#1-安装swagger工具" class="headerlink" title="1.安装swagger工具"></a>1.安装swagger工具</h2><blockquote><p>全局环境安装 swagger-go工具</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 工具安装</span><br>go install github.com<span class="hljs-regexp">/swaggo/</span>swag<span class="hljs-regexp">/cmd/</span>swag@latest<br><span class="hljs-comment"># 依赖源安装</span><br>go get -u github.com<span class="hljs-regexp">/swaggo/gi</span>n-swagger<br>go get -u github.com<span class="hljs-regexp">/swaggo/</span>files<br></code></pre></td></tr></table></figure><h2 id="2-初步使用Swagger"><a href="#2-初步使用Swagger" class="headerlink" title="2.初步使用Swagger"></a>2.初步使用Swagger</h2><blockquote><p><code>swag初始化</code> 默认生成文件.&#x2F;docs&#x2F;</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">swag <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure><p>main.go 中匿名引入包 “YouGoModName&#x2F;docs”</p><p><code>路由集成</code> 需要在路由中配置我们的swagger</p><p>例如：下面这段代码</p></blockquote><ol><li>初始化使用：在项目目录使用命令 <code>swag init</code></li><li>使用注解：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//@Summary创建文章</span><br><span class="hljs-comment">//@Producejson</span><br><span class="hljs-comment">//@Paramuser_namebodystringtrue&quot;账号&quot;</span><br><span class="hljs-comment">//@Parampasswordbodystringtrue&quot;密码&quot;</span><br><span class="hljs-comment">//@Paramemailbodystringfalse&quot;邮箱&quot;</span><br><span class="hljs-comment">//@Paramnick_namebodyintfalse&quot;昵称&quot;</span><br><span class="hljs-comment">//@Success200&#123;object&#125;Article&quot;成功&quot;</span><br><span class="hljs-comment">//@Failure400&#123;object&#125;string&quot;请求错误&quot;</span><br><span class="hljs-comment">//@Router/api/v1/user/register [post]</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">UserRegister</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-keyword">var</span> userRegisterService service.UserService<br>err := c.ShouldBindJSON(&amp;userRegisterService)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>c.JSON(<span class="hljs-number">400</span>, <span class="hljs-string">&quot;注册接口数据格式错误&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>res := userRegisterService.Register(c.Request.Context())<br>c.JSON(<span class="hljs-number">200</span>, res)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>路由组配置sawgger</li></ol><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewRouter</span><span class="hljs-params">()</span></span> *gin.Engine &#123;<br>r := gin.Default()<br><br>r.Use(middleware.Cors())<br><br><span class="hljs-comment">// 公共路由组</span><br>publicGroup := r.Group(<span class="hljs-string">&quot;&quot;</span>)<br>publicGroup.GET(<span class="hljs-string">&quot;/swagger/*any&quot;</span>, ginSwagger.WrapHandler(swaggerFiles.Handler))<br><br><span class="hljs-comment">// V1管理路由组</span><br>v1 := r.Group(<span class="hljs-string">&quot;api/v1&quot;</span>)<br>&#123;<br>v1.GET(<span class="hljs-string">&quot;ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.JSON(http.StatusOK, <span class="hljs-string">&quot;Success&quot;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 用户操作</span><br>v1.POST(<span class="hljs-string">&quot;user/register&quot;</span>, api.UserRegister)<br>&#125;<br><br><span class="hljs-keyword">return</span> r<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="4"><li>使用 <code>swag fmt </code> 格式化我们的注解信息</li><li>使用 <code>swag init</code> 重新加载生成我们的注解对应doc文件。</li><li>启动项目，点击：<a href="http://127.0.0.1/swagger/index.html">Swagger UI</a> 就可以看到我们的配置是否成功运行了。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Golang | go-swagger | gin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 下安装Golang环境</title>
    <link href="/2023/02/17/Linux-%E4%B8%8B%E5%AE%89%E8%A3%85Golang%E7%8E%AF%E5%A2%83/"/>
    <url>/2023/02/17/Linux-%E4%B8%8B%E5%AE%89%E8%A3%85Golang%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h2 id="环境安装前提"><a href="#环境安装前提" class="headerlink" title="环境安装前提"></a>环境安装前提</h2><p>  1.查看安装物理机信息<br>  <figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@VM</span><span class="hljs-number">-16</span><span class="hljs-number">-14</span>-centos ~]<span class="hljs-meta"># uname -m</span><br>x86_64<br></code></pre></td></tr></table></figure><br>  2.根据输出信息去Golang官网下载对应安装包<br>  [Golang官网](<a href="https://golang.google.cn/dl/">Downloads - The Go Programming Language (google.cn)</a>)<br>  3.使用远程拷贝命令</p>  <figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir">scp go1.<span class="hljs-number">20</span>.linux-amd64.tar.gz remote_username<span class="hljs-variable">@remote_ip</span><span class="hljs-symbol">:remote_file</span> <br><span class="hljs-comment">#例如我的</span><br>scp go1.<span class="hljs-number">20</span>.linux-amd64.tar.gz root<span class="hljs-variable">@192</span>.<span class="hljs-number">168.247</span>.<span class="hljs-number">1</span><span class="hljs-symbol">:/root</span><br></code></pre></td></tr></table></figure><p> 4.解压文件，并配置环境变量。<br>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#解压到  /usr/local</span><br>tar -C /usr/local -zxvf  go1.20.linux-amd64.tar.gz<br><span class="hljs-comment">#配置环境变量</span><br>sudo vim ~/.bashrc#在尾部写入<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">GOROOT</span>=/usr/local/go<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$PATH</span>:$GOROOT/bin<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">GOPATH</span>=/home/hesunfly/code/go<br><span class="hljs-comment">#保存退出</span><br>:wq<br></code></pre></td></tr></table></figure><br>  5.刷新配置<br><code>source ~/.bashrc</code><br>  6.测试使用<br>  <code>go env 正常输出即可</code><br>  7.配置七牛云代理</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">GO111MODULE</span>=on<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">GOPROXY</span>=https://goproxy.cn<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Golang Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/02/16/hello-world/"/>
    <url>/2023/02/16/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
